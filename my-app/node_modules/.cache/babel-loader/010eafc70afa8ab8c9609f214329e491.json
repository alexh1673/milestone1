{"ast":null,"code":"/**\n * @module sync-protocol\n */\n\nimport * as encoding from 'lib0/encoding';\nimport * as decoding from 'lib0/decoding';\nimport * as Y from 'yjs';\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.\n * Therefore it is necesarry that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nexport const messageYjsSyncStep1 = 0;\nexport const messageYjsSyncStep2 = 1;\nexport const messageYjsUpdate = 2;\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nexport const writeSyncStep1 = (encoder, doc) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep1);\n  const sv = Y.encodeStateVector(doc);\n  encoding.writeVarUint8Array(encoder, sv);\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nexport const writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep2);\n  encoding.writeVarUint8Array(encoder, Y.encodeStateAsUpdate(doc, encodedStateVector));\n};\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nexport const readSyncStep1 = (decoder, encoder, doc) => writeSyncStep2(encoder, doc, decoding.readVarUint8Array(decoder));\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    Y.applyUpdate(doc, decoding.readVarUint8Array(decoder), transactionOrigin);\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error);\n  }\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nexport const writeUpdate = (encoder, update) => {\n  encoding.writeVarUint(encoder, messageYjsUpdate);\n  encoding.writeVarUint8Array(encoder, update);\n};\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readUpdate = readSyncStep2;\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = decoding.readVarUint(decoder);\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc);\n      break;\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin);\n      break;\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin);\n      break;\n    default:\n      throw new Error('Unknown message type');\n  }\n  return messageType;\n};","map":{"version":3,"names":["encoding","decoding","Y","messageYjsSyncStep1","messageYjsSyncStep2","messageYjsUpdate","writeSyncStep1","encoder","doc","writeVarUint","sv","encodeStateVector","writeVarUint8Array","writeSyncStep2","encodedStateVector","encodeStateAsUpdate","readSyncStep1","decoder","readVarUint8Array","readSyncStep2","transactionOrigin","applyUpdate","error","console","writeUpdate","update","readUpdate","readSyncMessage","messageType","readVarUint","Error"],"sources":["/root/ms1/node_modules/y-protocols/sync.js"],"sourcesContent":["/**\n * @module sync-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as Y from 'yjs'\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.\n * Therefore it is necesarry that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nexport const messageYjsSyncStep1 = 0\nexport const messageYjsSyncStep2 = 1\nexport const messageYjsUpdate = 2\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nexport const writeSyncStep1 = (encoder, doc) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep1)\n  const sv = Y.encodeStateVector(doc)\n  encoding.writeVarUint8Array(encoder, sv)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nexport const writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  encoding.writeVarUint(encoder, messageYjsSyncStep2)\n  encoding.writeVarUint8Array(encoder, Y.encodeStateAsUpdate(doc, encodedStateVector))\n}\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nexport const readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, decoding.readVarUint8Array(decoder))\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    Y.applyUpdate(doc, decoding.readVarUint8Array(decoder), transactionOrigin)\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error('Caught error while handling a Yjs update', error)\n  }\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nexport const writeUpdate = (encoder, update) => {\n  encoding.writeVarUint(encoder, messageYjsUpdate)\n  encoding.writeVarUint8Array(encoder, update)\n}\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readUpdate = readSyncStep2\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nexport const readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = decoding.readVarUint(decoder)\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc)\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin)\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin)\n      break\n    default:\n      throw new Error('Unknown message type')\n  }\n  return messageType\n}\n"],"mappings":"AAAA;AACA;AACA;;AAEA,OAAO,KAAKA,QAAQ,MAAM,eAAe;AACzC,OAAO,KAAKC,QAAQ,MAAM,eAAe;AACzC,OAAO,KAAKC,CAAC,MAAM,KAAK;;AAExB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,mBAAmB,GAAG,CAAC;AACpC,OAAO,MAAMC,mBAAmB,GAAG,CAAC;AACpC,OAAO,MAAMC,gBAAgB,GAAG,CAAC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAG,CAACC,OAAO,EAAEC,GAAG,KAAK;EAC9CR,QAAQ,CAACS,YAAY,CAACF,OAAO,EAAEJ,mBAAmB,CAAC;EACnD,MAAMO,EAAE,GAAGR,CAAC,CAACS,iBAAiB,CAACH,GAAG,CAAC;EACnCR,QAAQ,CAACY,kBAAkB,CAACL,OAAO,EAAEG,EAAE,CAAC;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,cAAc,GAAG,CAACN,OAAO,EAAEC,GAAG,EAAEM,kBAAkB,KAAK;EAClEd,QAAQ,CAACS,YAAY,CAACF,OAAO,EAAEH,mBAAmB,CAAC;EACnDJ,QAAQ,CAACY,kBAAkB,CAACL,OAAO,EAAEL,CAAC,CAACa,mBAAmB,CAACP,GAAG,EAAEM,kBAAkB,CAAC,CAAC;AACtF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,aAAa,GAAG,CAACC,OAAO,EAAEV,OAAO,EAAEC,GAAG,KACjDK,cAAc,CAACN,OAAO,EAAEC,GAAG,EAAEP,QAAQ,CAACiB,iBAAiB,CAACD,OAAO,CAAC,CAAC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,aAAa,GAAG,CAACF,OAAO,EAAET,GAAG,EAAEY,iBAAiB,KAAK;EAChE,IAAI;IACFlB,CAAC,CAACmB,WAAW,CAACb,GAAG,EAAEP,QAAQ,CAACiB,iBAAiB,CAACD,OAAO,CAAC,EAAEG,iBAAiB,CAAC;EAC5E,CAAC,CAAC,OAAOE,KAAK,EAAE;IACd;IACAC,OAAO,CAACD,KAAK,CAAC,0CAA0C,EAAEA,KAAK,CAAC;EAClE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAME,WAAW,GAAG,CAACjB,OAAO,EAAEkB,MAAM,KAAK;EAC9CzB,QAAQ,CAACS,YAAY,CAACF,OAAO,EAAEF,gBAAgB,CAAC;EAChDL,QAAQ,CAACY,kBAAkB,CAACL,OAAO,EAAEkB,MAAM,CAAC;AAC9C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAGP,aAAa;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMQ,eAAe,GAAG,CAACV,OAAO,EAAEV,OAAO,EAAEC,GAAG,EAAEY,iBAAiB,KAAK;EAC3E,MAAMQ,WAAW,GAAG3B,QAAQ,CAAC4B,WAAW,CAACZ,OAAO,CAAC;EACjD,QAAQW,WAAW;IACjB,KAAKzB,mBAAmB;MACtBa,aAAa,CAACC,OAAO,EAAEV,OAAO,EAAEC,GAAG,CAAC;MACpC;IACF,KAAKJ,mBAAmB;MACtBe,aAAa,CAACF,OAAO,EAAET,GAAG,EAAEY,iBAAiB,CAAC;MAC9C;IACF,KAAKf,gBAAgB;MACnBqB,UAAU,CAACT,OAAO,EAAET,GAAG,EAAEY,iBAAiB,CAAC;MAC3C;IACF;MACE,MAAM,IAAIU,KAAK,CAAC,sBAAsB,CAAC;EAAA;EAE3C,OAAOF,WAAW;AACpB,CAAC"},"metadata":{},"sourceType":"module"}