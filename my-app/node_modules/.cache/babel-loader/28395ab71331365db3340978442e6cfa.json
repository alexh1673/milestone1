{"ast":null,"code":"/* eslint-env browser */\n\nimport * as encoding from 'lib0/encoding';\nimport * as decoding from 'lib0/decoding';\nimport * as promise from 'lib0/promise';\nimport * as error from 'lib0/error';\nimport * as string from 'lib0/string';\n\n/**\n * @param {string} secret\n * @param {string} roomName\n * @return {PromiseLike<CryptoKey>}\n */\nexport const deriveKey = (secret, roomName) => {\n  const secretBuffer = string.encodeUtf8(secret).buffer;\n  const salt = string.encodeUtf8(roomName).buffer;\n  return crypto.subtle.importKey('raw', secretBuffer, 'PBKDF2', false, ['deriveKey']).then(keyMaterial => crypto.subtle.deriveKey({\n    name: 'PBKDF2',\n    salt,\n    iterations: 100000,\n    hash: 'SHA-256'\n  }, keyMaterial, {\n    name: 'AES-GCM',\n    length: 256\n  }, true, ['encrypt', 'decrypt']));\n};\n\n/**\n * @param {Uint8Array} data data to be encrypted\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} encrypted, base64 encoded message\n */\nexport const encrypt = (data, key) => {\n  if (!key) {\n    return (/** @type {PromiseLike<Uint8Array>} */promise.resolve(data)\n    );\n  }\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n  return crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, data).then(cipher => {\n    const encryptedDataEncoder = encoding.createEncoder();\n    encoding.writeVarString(encryptedDataEncoder, 'AES-GCM');\n    encoding.writeVarUint8Array(encryptedDataEncoder, iv);\n    encoding.writeVarUint8Array(encryptedDataEncoder, new Uint8Array(cipher));\n    return encoding.toUint8Array(encryptedDataEncoder);\n  });\n};\n\n/**\n * @param {Object} data data to be encrypted\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} encrypted data, if key is provided\n */\nexport const encryptJson = (data, key) => {\n  const dataEncoder = encoding.createEncoder();\n  encoding.writeAny(dataEncoder, data);\n  return encrypt(encoding.toUint8Array(dataEncoder), key);\n};\n\n/**\n * @param {Uint8Array} data\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} decrypted buffer\n */\nexport const decrypt = (data, key) => {\n  if (!key) {\n    return (/** @type {PromiseLike<Uint8Array>} */promise.resolve(data)\n    );\n  }\n  const dataDecoder = decoding.createDecoder(data);\n  const algorithm = decoding.readVarString(dataDecoder);\n  if (algorithm !== 'AES-GCM') {\n    promise.reject(error.create('Unknown encryption algorithm'));\n  }\n  const iv = decoding.readVarUint8Array(dataDecoder);\n  const cipher = decoding.readVarUint8Array(dataDecoder);\n  return crypto.subtle.decrypt({\n    name: 'AES-GCM',\n    iv\n  }, key, cipher).then(data => new Uint8Array(data));\n};\n\n/**\n * @param {Uint8Array} data\n * @param {CryptoKey?} key\n * @return {PromiseLike<Object>} decrypted object\n */\nexport const decryptJson = (data, key) => decrypt(data, key).then(decryptedValue => decoding.readAny(decoding.createDecoder(new Uint8Array(decryptedValue))));","map":{"version":3,"names":["encoding","decoding","promise","error","string","deriveKey","secret","roomName","secretBuffer","encodeUtf8","buffer","salt","crypto","subtle","importKey","then","keyMaterial","name","iterations","hash","length","encrypt","data","key","resolve","iv","getRandomValues","Uint8Array","cipher","encryptedDataEncoder","createEncoder","writeVarString","writeVarUint8Array","toUint8Array","encryptJson","dataEncoder","writeAny","decrypt","dataDecoder","createDecoder","algorithm","readVarString","reject","create","readVarUint8Array","decryptJson","decryptedValue","readAny"],"sources":["/root/ms1/node_modules/y-webrtc/src/crypto.js"],"sourcesContent":["/* eslint-env browser */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as promise from 'lib0/promise'\nimport * as error from 'lib0/error'\nimport * as string from 'lib0/string'\n\n/**\n * @param {string} secret\n * @param {string} roomName\n * @return {PromiseLike<CryptoKey>}\n */\nexport const deriveKey = (secret, roomName) => {\n  const secretBuffer = string.encodeUtf8(secret).buffer\n  const salt = string.encodeUtf8(roomName).buffer\n  return crypto.subtle.importKey(\n    'raw',\n    secretBuffer,\n    'PBKDF2',\n    false,\n    ['deriveKey']\n  ).then(keyMaterial =>\n    crypto.subtle.deriveKey(\n      {\n        name: 'PBKDF2',\n        salt,\n        iterations: 100000,\n        hash: 'SHA-256'\n      },\n      keyMaterial,\n      {\n        name: 'AES-GCM',\n        length: 256\n      },\n      true,\n      ['encrypt', 'decrypt']\n    )\n  )\n}\n\n/**\n * @param {Uint8Array} data data to be encrypted\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} encrypted, base64 encoded message\n */\nexport const encrypt = (data, key) => {\n  if (!key) {\n    return /** @type {PromiseLike<Uint8Array>} */ (promise.resolve(data))\n  }\n  const iv = crypto.getRandomValues(new Uint8Array(12))\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv\n    },\n    key,\n    data\n  ).then(cipher => {\n    const encryptedDataEncoder = encoding.createEncoder()\n    encoding.writeVarString(encryptedDataEncoder, 'AES-GCM')\n    encoding.writeVarUint8Array(encryptedDataEncoder, iv)\n    encoding.writeVarUint8Array(encryptedDataEncoder, new Uint8Array(cipher))\n    return encoding.toUint8Array(encryptedDataEncoder)\n  })\n}\n\n/**\n * @param {Object} data data to be encrypted\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} encrypted data, if key is provided\n */\nexport const encryptJson = (data, key) => {\n  const dataEncoder = encoding.createEncoder()\n  encoding.writeAny(dataEncoder, data)\n  return encrypt(encoding.toUint8Array(dataEncoder), key)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {CryptoKey?} key\n * @return {PromiseLike<Uint8Array>} decrypted buffer\n */\nexport const decrypt = (data, key) => {\n  if (!key) {\n    return /** @type {PromiseLike<Uint8Array>} */ (promise.resolve(data))\n  }\n  const dataDecoder = decoding.createDecoder(data)\n  const algorithm = decoding.readVarString(dataDecoder)\n  if (algorithm !== 'AES-GCM') {\n    promise.reject(error.create('Unknown encryption algorithm'))\n  }\n  const iv = decoding.readVarUint8Array(dataDecoder)\n  const cipher = decoding.readVarUint8Array(dataDecoder)\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv\n    },\n    key,\n    cipher\n  ).then(data => new Uint8Array(data))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {CryptoKey?} key\n * @return {PromiseLike<Object>} decrypted object\n */\nexport const decryptJson = (data, key) =>\n  decrypt(data, key).then(decryptedValue =>\n    decoding.readAny(decoding.createDecoder(new Uint8Array(decryptedValue)))\n  )\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}