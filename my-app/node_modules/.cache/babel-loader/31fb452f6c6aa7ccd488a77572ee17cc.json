{"ast":null,"code":"/* global localStorage, addEventListener */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* istanbul ignore next */\nclass VarStoragePolyfill {\n  constructor() {\n    this.map = new Map();\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem(key, newValue) {\n    this.map.set(key, newValue);\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem(key) {\n    return this.map.get(key);\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill();\nlet usePolyfill = true;\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  /* istanbul ignore next */\n  if (typeof localStorage !== 'undefined') {\n    _localStorage = localStorage;\n    usePolyfill = false;\n  }\n} catch (e) {}\n\n/* istanbul ignore next */\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\nexport const varStorage = _localStorage;\n\n/* istanbul ignore next */\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\nexport const onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */eventHandler);","map":{"version":3,"names":["VarStoragePolyfill","constructor","map","Map","setItem","key","newValue","set","getItem","get","_localStorage","usePolyfill","localStorage","e","varStorage","onChange","eventHandler","addEventListener"],"sources":["/root/ms1/my-app/node_modules/lib0/storage.js"],"sourcesContent":["/* global localStorage, addEventListener */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* istanbul ignore next */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\nlet usePolyfill = true\n\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  /* istanbul ignore next */\n  if (typeof localStorage !== 'undefined') {\n    _localStorage = localStorage\n    usePolyfill = false\n  }\n} catch (e) { }\n\n/* istanbul ignore next */\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\nexport const varStorage = _localStorage\n\n/* istanbul ignore next */\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\nexport const onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler))\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMA,kBAAkB,CAAC;EACvBC,WAAW,GAAI;IACb,IAAI,CAACC,GAAG,GAAG,IAAIC,GAAG,EAAE;EACtB;;EAEA;AACF;AACA;AACA;EACEC,OAAO,CAAEC,GAAG,EAAEC,QAAQ,EAAE;IACtB,IAAI,CAACJ,GAAG,CAACK,GAAG,CAACF,GAAG,EAAEC,QAAQ,CAAC;EAC7B;;EAEA;AACF;AACA;EACEE,OAAO,CAAEH,GAAG,EAAE;IACZ,OAAO,IAAI,CAACH,GAAG,CAACO,GAAG,CAACJ,GAAG,CAAC;EAC1B;AACF;;AAEA;AACA;AACA;AACA;AACA,IAAIK,aAAa,GAAG,IAAIV,kBAAkB,EAAE;AAC5C,IAAIW,WAAW,GAAG,IAAI;AAEtB,IAAI;EACF;EACA;EACA,IAAI,OAAOC,YAAY,KAAK,WAAW,EAAE;IACvCF,aAAa,GAAGE,YAAY;IAC5BD,WAAW,GAAG,KAAK;EACrB;AACF,CAAC,CAAC,OAAOE,CAAC,EAAE,CAAE;;AAEd;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAGJ,aAAa;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,QAAQ,GAAGC,YAAY,IAAIL,WAAW,IAAIM,gBAAgB,CAAC,SAAS,EAAE,kBAAoBD,YAAY,CAAE"},"metadata":{},"sourceType":"module"}