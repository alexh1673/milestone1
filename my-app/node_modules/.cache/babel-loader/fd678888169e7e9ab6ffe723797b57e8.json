{"ast":null,"code":"import * as ws from 'lib0/websocket';\nimport * as map from 'lib0/map';\nimport * as error from 'lib0/error';\nimport * as random from 'lib0/random';\nimport * as encoding from 'lib0/encoding';\nimport * as decoding from 'lib0/decoding';\nimport { Observable } from 'lib0/observable';\nimport * as logging from 'lib0/logging';\nimport * as promise from 'lib0/promise';\nimport * as bc from 'lib0/broadcastchannel';\nimport * as buffer from 'lib0/buffer';\nimport * as math from 'lib0/math';\nimport { createMutex } from 'lib0/mutex';\nimport * as Y from 'yjs'; // eslint-disable-line\nimport Peer from 'simple-peer/simplepeer.min.js';\nimport * as syncProtocol from 'y-protocols/sync';\nimport * as awarenessProtocol from 'y-protocols/awareness';\nimport * as cryptoutils from './crypto.js';\nconst log = logging.createModuleLogger('y-webrtc');\nconst messageSync = 0;\nconst messageQueryAwareness = 3;\nconst messageAwareness = 1;\nconst messageBcPeerId = 4;\n\n/**\n * @type {Map<string, SignalingConn>}\n */\nconst signalingConns = new Map();\n\n/**\n * @type {Map<string,Room>}\n */\nconst rooms = new Map();\n\n/**\n * @param {Room} room\n */\nconst checkIsSynced = room => {\n  let synced = true;\n  room.webrtcConns.forEach(peer => {\n    if (!peer.synced) {\n      synced = false;\n    }\n  });\n  if (!synced && room.synced || synced && !room.synced) {\n    room.synced = synced;\n    room.provider.emit('synced', [{\n      synced\n    }]);\n    log('synced ', logging.BOLD, room.name, logging.UNBOLD, ' with all peers');\n  }\n};\n\n/**\n * @param {Room} room\n * @param {Uint8Array} buf\n * @param {function} syncedCallback\n * @return {encoding.Encoder?}\n */\nconst readMessage = (room, buf, syncedCallback) => {\n  const decoder = decoding.createDecoder(buf);\n  const encoder = encoding.createEncoder();\n  const messageType = decoding.readVarUint(decoder);\n  if (room === undefined) {\n    return null;\n  }\n  const awareness = room.awareness;\n  const doc = room.doc;\n  let sendReply = false;\n  switch (messageType) {\n    case messageSync:\n      {\n        encoding.writeVarUint(encoder, messageSync);\n        const syncMessageType = syncProtocol.readSyncMessage(decoder, encoder, doc, room);\n        if (syncMessageType === syncProtocol.messageYjsSyncStep2 && !room.synced) {\n          syncedCallback();\n        }\n        if (syncMessageType === syncProtocol.messageYjsSyncStep1) {\n          sendReply = true;\n        }\n        break;\n      }\n    case messageQueryAwareness:\n      encoding.writeVarUint(encoder, messageAwareness);\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, Array.from(awareness.getStates().keys())));\n      sendReply = true;\n      break;\n    case messageAwareness:\n      awarenessProtocol.applyAwarenessUpdate(awareness, decoding.readVarUint8Array(decoder), room);\n      break;\n    case messageBcPeerId:\n      {\n        const add = decoding.readUint8(decoder) === 1;\n        const peerName = decoding.readVarString(decoder);\n        if (peerName !== room.peerId && (room.bcConns.has(peerName) && !add || !room.bcConns.has(peerName) && add)) {\n          const removed = [];\n          const added = [];\n          if (add) {\n            room.bcConns.add(peerName);\n            added.push(peerName);\n          } else {\n            room.bcConns.delete(peerName);\n            removed.push(peerName);\n          }\n          room.provider.emit('peers', [{\n            added,\n            removed,\n            webrtcPeers: Array.from(room.webrtcConns.keys()),\n            bcPeers: Array.from(room.bcConns)\n          }]);\n          broadcastBcPeerId(room);\n        }\n        break;\n      }\n    default:\n      console.error('Unable to compute message');\n      return encoder;\n  }\n  if (!sendReply) {\n    // nothing has been written, no answer created\n    return null;\n  }\n  return encoder;\n};\n\n/**\n * @param {WebrtcConn} peerConn\n * @param {Uint8Array} buf\n * @return {encoding.Encoder?}\n */\nconst readPeerMessage = (peerConn, buf) => {\n  const room = peerConn.room;\n  log('received message from ', logging.BOLD, peerConn.remotePeerId, logging.GREY, ' (', room.name, ')', logging.UNBOLD, logging.UNCOLOR);\n  return readMessage(room, buf, () => {\n    peerConn.synced = true;\n    log('synced ', logging.BOLD, room.name, logging.UNBOLD, ' with ', logging.BOLD, peerConn.remotePeerId);\n    checkIsSynced(room);\n  });\n};\n\n/**\n * @param {WebrtcConn} webrtcConn\n * @param {encoding.Encoder} encoder\n */\nconst sendWebrtcConn = (webrtcConn, encoder) => {\n  log('send message to ', logging.BOLD, webrtcConn.remotePeerId, logging.UNBOLD, logging.GREY, ' (', webrtcConn.room.name, ')', logging.UNCOLOR);\n  try {\n    webrtcConn.peer.send(encoding.toUint8Array(encoder));\n  } catch (e) {}\n};\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastWebrtcConn = (room, m) => {\n  log('broadcast message in ', logging.BOLD, room.name, logging.UNBOLD);\n  room.webrtcConns.forEach(conn => {\n    try {\n      conn.peer.send(m);\n    } catch (e) {}\n  });\n};\nexport class WebrtcConn {\n  /**\n   * @param {SignalingConn} signalingConn\n   * @param {boolean} initiator\n   * @param {string} remotePeerId\n   * @param {Room} room\n   */\n  constructor(signalingConn, initiator, remotePeerId, room) {\n    log('establishing connection to ', logging.BOLD, remotePeerId);\n    this.room = room;\n    this.remotePeerId = remotePeerId;\n    this.closed = false;\n    this.connected = false;\n    this.synced = false;\n    /**\n     * @type {any}\n     */\n    this.peer = new Peer({\n      initiator,\n      ...room.provider.peerOpts\n    });\n    this.peer.on('signal', signal => {\n      publishSignalingMessage(signalingConn, room, {\n        to: remotePeerId,\n        from: room.peerId,\n        type: 'signal',\n        signal\n      });\n    });\n    this.peer.on('connect', () => {\n      log('connected to ', logging.BOLD, remotePeerId);\n      this.connected = true;\n      // send sync step 1\n      const provider = room.provider;\n      const doc = provider.doc;\n      const awareness = room.awareness;\n      const encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageSync);\n      syncProtocol.writeSyncStep1(encoder, doc);\n      sendWebrtcConn(this, encoder);\n      const awarenessStates = awareness.getStates();\n      if (awarenessStates.size > 0) {\n        const encoder = encoding.createEncoder();\n        encoding.writeVarUint(encoder, messageAwareness);\n        encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, Array.from(awarenessStates.keys())));\n        sendWebrtcConn(this, encoder);\n      }\n    });\n    this.peer.on('close', () => {\n      this.connected = false;\n      this.closed = true;\n      if (room.webrtcConns.has(this.remotePeerId)) {\n        room.webrtcConns.delete(this.remotePeerId);\n        room.provider.emit('peers', [{\n          removed: [this.remotePeerId],\n          added: [],\n          webrtcPeers: Array.from(room.webrtcConns.keys()),\n          bcPeers: Array.from(room.bcConns)\n        }]);\n      }\n      checkIsSynced(room);\n      this.peer.destroy();\n      log('closed connection to ', logging.BOLD, remotePeerId);\n      announceSignalingInfo(room);\n    });\n    this.peer.on('error', err => {\n      log('Error in connection to ', logging.BOLD, remotePeerId, ': ', err);\n      announceSignalingInfo(room);\n    });\n    this.peer.on('data', data => {\n      const answer = readPeerMessage(this, data);\n      if (answer !== null) {\n        sendWebrtcConn(this, answer);\n      }\n    });\n  }\n  destroy() {\n    this.peer.destroy();\n  }\n}\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastBcMessage = (room, m) => cryptoutils.encrypt(m, room.key).then(data => room.mux(() => bc.publish(room.name, data)));\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastRoomMessage = (room, m) => {\n  if (room.bcconnected) {\n    broadcastBcMessage(room, m);\n  }\n  broadcastWebrtcConn(room, m);\n};\n\n/**\n * @param {Room} room\n */\nconst announceSignalingInfo = room => {\n  signalingConns.forEach(conn => {\n    // only subcribe if connection is established, otherwise the conn automatically subscribes to all rooms\n    if (conn.connected) {\n      conn.send({\n        type: 'subscribe',\n        topics: [room.name]\n      });\n      if (room.webrtcConns.size < room.provider.maxConns) {\n        publishSignalingMessage(conn, room, {\n          type: 'announce',\n          from: room.peerId\n        });\n      }\n    }\n  });\n};\n\n/**\n * @param {Room} room\n */\nconst broadcastBcPeerId = room => {\n  if (room.provider.filterBcConns) {\n    // broadcast peerId via broadcastchannel\n    const encoderPeerIdBc = encoding.createEncoder();\n    encoding.writeVarUint(encoderPeerIdBc, messageBcPeerId);\n    encoding.writeUint8(encoderPeerIdBc, 1);\n    encoding.writeVarString(encoderPeerIdBc, room.peerId);\n    broadcastBcMessage(room, encoding.toUint8Array(encoderPeerIdBc));\n  }\n};\nexport class Room {\n  /**\n   * @param {Y.Doc} doc\n   * @param {WebrtcProvider} provider\n   * @param {string} name\n   * @param {CryptoKey|null} key\n   */\n  constructor(doc, provider, name, key) {\n    /**\n     * Do not assume that peerId is unique. This is only meant for sending signaling messages.\n     *\n     * @type {string}\n     */\n    this.peerId = random.uuidv4();\n    this.doc = doc;\n    /**\n     * @type {awarenessProtocol.Awareness}\n     */\n    this.awareness = provider.awareness;\n    this.provider = provider;\n    this.synced = false;\n    this.name = name;\n    // @todo make key secret by scoping\n    this.key = key;\n    /**\n     * @type {Map<string, WebrtcConn>}\n     */\n    this.webrtcConns = new Map();\n    /**\n     * @type {Set<string>}\n     */\n    this.bcConns = new Set();\n    this.mux = createMutex();\n    this.bcconnected = false;\n    /**\n     * @param {ArrayBuffer} data\n     */\n    this._bcSubscriber = data => cryptoutils.decrypt(new Uint8Array(data), key).then(m => this.mux(() => {\n      const reply = readMessage(this, m, () => {});\n      if (reply) {\n        broadcastBcMessage(this, encoding.toUint8Array(reply));\n      }\n    }));\n    /**\n     * Listens to Yjs updates and sends them to remote peers\n     *\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n    this._docUpdateHandler = (update, origin) => {\n      const encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageSync);\n      syncProtocol.writeUpdate(encoder, update);\n      broadcastRoomMessage(this, encoding.toUint8Array(encoder));\n    };\n    /**\n     * Listens to Awareness updates and sends them to remote peers\n     *\n     * @param {any} changed\n     * @param {any} origin\n     */\n    this._awarenessUpdateHandler = (_ref, origin) => {\n      let {\n        added,\n        updated,\n        removed\n      } = _ref;\n      const changedClients = added.concat(updated).concat(removed);\n      const encoderAwareness = encoding.createEncoder();\n      encoding.writeVarUint(encoderAwareness, messageAwareness);\n      encoding.writeVarUint8Array(encoderAwareness, awarenessProtocol.encodeAwarenessUpdate(this.awareness, changedClients));\n      broadcastRoomMessage(this, encoding.toUint8Array(encoderAwareness));\n    };\n    this._beforeUnloadHandler = () => {\n      awarenessProtocol.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload');\n      rooms.forEach(room => {\n        room.disconnect();\n      });\n    };\n    if (typeof window !== 'undefined') {\n      window.addEventListener('beforeunload', this._beforeUnloadHandler);\n    } else if (typeof process !== 'undefined') {\n      process.on('exit', this._beforeUnloadHandler);\n    }\n  }\n  connect() {\n    this.doc.on('update', this._docUpdateHandler);\n    this.awareness.on('update', this._awarenessUpdateHandler);\n    // signal through all available signaling connections\n    announceSignalingInfo(this);\n    const roomName = this.name;\n    bc.subscribe(roomName, this._bcSubscriber);\n    this.bcconnected = true;\n    // broadcast peerId via broadcastchannel\n    broadcastBcPeerId(this);\n    // write sync step 1\n    const encoderSync = encoding.createEncoder();\n    encoding.writeVarUint(encoderSync, messageSync);\n    syncProtocol.writeSyncStep1(encoderSync, this.doc);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderSync));\n    // broadcast local state\n    const encoderState = encoding.createEncoder();\n    encoding.writeVarUint(encoderState, messageSync);\n    syncProtocol.writeSyncStep2(encoderState, this.doc);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderState));\n    // write queryAwareness\n    const encoderAwarenessQuery = encoding.createEncoder();\n    encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderAwarenessQuery));\n    // broadcast local awareness state\n    const encoderAwarenessState = encoding.createEncoder();\n    encoding.writeVarUint(encoderAwarenessState, messageAwareness);\n    encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));\n    broadcastBcMessage(this, encoding.toUint8Array(encoderAwarenessState));\n  }\n  disconnect() {\n    // signal through all available signaling connections\n    signalingConns.forEach(conn => {\n      if (conn.connected) {\n        conn.send({\n          type: 'unsubscribe',\n          topics: [this.name]\n        });\n      }\n    });\n    awarenessProtocol.removeAwarenessStates(this.awareness, [this.doc.clientID], 'disconnect');\n    // broadcast peerId removal via broadcastchannel\n    const encoderPeerIdBc = encoding.createEncoder();\n    encoding.writeVarUint(encoderPeerIdBc, messageBcPeerId);\n    encoding.writeUint8(encoderPeerIdBc, 0); // remove peerId from other bc peers\n    encoding.writeVarString(encoderPeerIdBc, this.peerId);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderPeerIdBc));\n    bc.unsubscribe(this.name, this._bcSubscriber);\n    this.bcconnected = false;\n    this.doc.off('update', this._docUpdateHandler);\n    this.awareness.off('update', this._awarenessUpdateHandler);\n    this.webrtcConns.forEach(conn => conn.destroy());\n  }\n  destroy() {\n    this.disconnect();\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('beforeunload', this._beforeUnloadHandler);\n    } else if (typeof process !== 'undefined') {\n      process.off('exit', this._beforeUnloadHandler);\n    }\n  }\n}\n\n/**\n * @param {Y.Doc} doc\n * @param {WebrtcProvider} provider\n * @param {string} name\n * @param {CryptoKey|null} key\n * @return {Room}\n */\nconst openRoom = (doc, provider, name, key) => {\n  // there must only be one room\n  if (rooms.has(name)) {\n    throw error.create(`A Yjs Doc connected to room \"${name}\" already exists!`);\n  }\n  const room = new Room(doc, provider, name, key);\n  rooms.set(name, /** @type {Room} */room);\n  return room;\n};\n\n/**\n * @param {SignalingConn} conn\n * @param {Room} room\n * @param {any} data\n */\nconst publishSignalingMessage = (conn, room, data) => {\n  if (room.key) {\n    cryptoutils.encryptJson(data, room.key).then(data => {\n      conn.send({\n        type: 'publish',\n        topic: room.name,\n        data: buffer.toBase64(data)\n      });\n    });\n  } else {\n    conn.send({\n      type: 'publish',\n      topic: room.name,\n      data\n    });\n  }\n};\nexport class SignalingConn extends ws.WebsocketClient {\n  constructor(url) {\n    super(url);\n    /**\n     * @type {Set<WebrtcProvider>}\n     */\n    this.providers = new Set();\n    this.on('connect', () => {\n      log(`connected (${url})`);\n      const topics = Array.from(rooms.keys());\n      this.send({\n        type: 'subscribe',\n        topics\n      });\n      rooms.forEach(room => publishSignalingMessage(this, room, {\n        type: 'announce',\n        from: room.peerId\n      }));\n    });\n    this.on('message', m => {\n      switch (m.type) {\n        case 'publish':\n          {\n            const roomName = m.topic;\n            const room = rooms.get(roomName);\n            if (room == null || typeof roomName !== 'string') {\n              return;\n            }\n            const execMessage = data => {\n              const webrtcConns = room.webrtcConns;\n              const peerId = room.peerId;\n              if (data == null || data.from === peerId || data.to !== undefined && data.to !== peerId || room.bcConns.has(data.from)) {\n                // ignore messages that are not addressed to this conn, or from clients that are connected via broadcastchannel\n                return;\n              }\n              const emitPeerChange = webrtcConns.has(data.from) ? () => {} : () => room.provider.emit('peers', [{\n                removed: [],\n                added: [data.from],\n                webrtcPeers: Array.from(room.webrtcConns.keys()),\n                bcPeers: Array.from(room.bcConns)\n              }]);\n              switch (data.type) {\n                case 'announce':\n                  if (webrtcConns.size < room.provider.maxConns) {\n                    map.setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, true, data.from, room));\n                    emitPeerChange();\n                  }\n                  break;\n                case 'signal':\n                  if (data.to === peerId) {\n                    map.setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, false, data.from, room)).peer.signal(data.signal);\n                    emitPeerChange();\n                  }\n                  break;\n              }\n            };\n            if (room.key) {\n              if (typeof m.data === 'string') {\n                cryptoutils.decryptJson(buffer.fromBase64(m.data), room.key).then(execMessage);\n              }\n            } else {\n              execMessage(m.data);\n            }\n          }\n      }\n    });\n    this.on('disconnect', () => log(`disconnect (${url})`));\n  }\n}\n\n/**\n * @extends Observable<string>\n */\nexport class WebrtcProvider extends Observable {\n  /**\n   * @param {string} roomName\n   * @param {Y.Doc} doc\n   * @param {Object} [opts]\n   * @param {Array<string>?} [opts.signaling]\n   * @param {string?} [opts.password]\n   * @param {awarenessProtocol.Awareness?} [opts.awareness]\n   * @param {number?} [opts.maxConns]\n   * @param {boolean?} [opts.filterBcConns]\n   * @param {any?} [opts.peerOpts]\n   */\n  constructor(roomName, doc) {\n    let {\n      signaling = ['wss://signaling.yjs.dev', 'wss://y-webrtc-signaling-eu.herokuapp.com', 'wss://y-webrtc-signaling-us.herokuapp.com'],\n      password = null,\n      awareness = new awarenessProtocol.Awareness(doc),\n      maxConns = 20 + math.floor(random.rand() * 15),\n      // the random factor reduces the chance that n clients form a cluster\n      filterBcConns = true,\n      peerOpts = {} // simple-peer options. See https://github.com/feross/simple-peer#peer--new-peeropts\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.roomName = roomName;\n    this.doc = doc;\n    this.filterBcConns = filterBcConns;\n    /**\n     * @type {awarenessProtocol.Awareness}\n     */\n    this.awareness = awareness;\n    this.shouldConnect = false;\n    this.signalingUrls = signaling;\n    this.signalingConns = [];\n    this.maxConns = maxConns;\n    this.peerOpts = peerOpts;\n    /**\n     * @type {PromiseLike<CryptoKey | null>}\n     */\n    this.key = password ? cryptoutils.deriveKey(password, roomName) : /** @type {PromiseLike<null>} */promise.resolve(null);\n    /**\n     * @type {Room|null}\n     */\n    this.room = null;\n    this.key.then(key => {\n      this.room = openRoom(doc, this, roomName, key);\n      if (this.shouldConnect) {\n        this.room.connect();\n      } else {\n        this.room.disconnect();\n      }\n    });\n    this.connect();\n    this.destroy = this.destroy.bind(this);\n    doc.on('destroy', this.destroy);\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get connected() {\n    return this.room !== null && this.shouldConnect;\n  }\n  connect() {\n    this.shouldConnect = true;\n    this.signalingUrls.forEach(url => {\n      const signalingConn = map.setIfUndefined(signalingConns, url, () => new SignalingConn(url));\n      this.signalingConns.push(signalingConn);\n      signalingConn.providers.add(this);\n    });\n    if (this.room) {\n      this.room.connect();\n    }\n  }\n  disconnect() {\n    this.shouldConnect = false;\n    this.signalingConns.forEach(conn => {\n      conn.providers.delete(this);\n      if (conn.providers.size === 0) {\n        conn.destroy();\n        signalingConns.delete(conn.url);\n      }\n    });\n    if (this.room) {\n      this.room.disconnect();\n    }\n  }\n  destroy() {\n    this.doc.off('destroy', this.destroy);\n    // need to wait for key before deleting room\n    this.key.then(() => {\n      /** @type {Room} */this.room.destroy();\n      rooms.delete(this.roomName);\n    });\n    super.destroy();\n  }\n}","map":{"version":3,"names":["ws","map","error","random","encoding","decoding","Observable","logging","promise","bc","buffer","math","createMutex","Y","Peer","syncProtocol","awarenessProtocol","cryptoutils","log","createModuleLogger","messageSync","messageQueryAwareness","messageAwareness","messageBcPeerId","signalingConns","Map","rooms","checkIsSynced","room","synced","webrtcConns","forEach","peer","provider","emit","BOLD","name","UNBOLD","readMessage","buf","syncedCallback","decoder","createDecoder","encoder","createEncoder","messageType","readVarUint","undefined","awareness","doc","sendReply","writeVarUint","syncMessageType","readSyncMessage","messageYjsSyncStep2","messageYjsSyncStep1","writeVarUint8Array","encodeAwarenessUpdate","Array","from","getStates","keys","applyAwarenessUpdate","readVarUint8Array","add","readUint8","peerName","readVarString","peerId","bcConns","has","removed","added","push","delete","webrtcPeers","bcPeers","broadcastBcPeerId","console","readPeerMessage","peerConn","remotePeerId","GREY","UNCOLOR","sendWebrtcConn","webrtcConn","send","toUint8Array","e","broadcastWebrtcConn","m","conn","WebrtcConn","constructor","signalingConn","initiator","closed","connected","peerOpts","on","signal","publishSignalingMessage","to","type","writeSyncStep1","awarenessStates","size","destroy","announceSignalingInfo","err","data","answer","broadcastBcMessage","encrypt","key","then","mux","publish","broadcastRoomMessage","bcconnected","topics","maxConns","filterBcConns","encoderPeerIdBc","writeUint8","writeVarString","Room","uuidv4","Set","_bcSubscriber","decrypt","Uint8Array","reply","_docUpdateHandler","update","origin","writeUpdate","_awarenessUpdateHandler","updated","changedClients","concat","encoderAwareness","_beforeUnloadHandler","removeAwarenessStates","clientID","disconnect","window","addEventListener","process","connect","roomName","subscribe","encoderSync","encoderState","writeSyncStep2","encoderAwarenessQuery","encoderAwarenessState","unsubscribe","off","removeEventListener","openRoom","create","set","encryptJson","topic","toBase64","SignalingConn","WebsocketClient","url","providers","get","execMessage","emitPeerChange","setIfUndefined","decryptJson","fromBase64","WebrtcProvider","signaling","password","Awareness","floor","rand","shouldConnect","signalingUrls","deriveKey","resolve","bind"],"sources":["/root/ms1/node_modules/y-webrtc/src/y-webrtc.js"],"sourcesContent":["import * as ws from 'lib0/websocket'\nimport * as map from 'lib0/map'\nimport * as error from 'lib0/error'\nimport * as random from 'lib0/random'\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport { Observable } from 'lib0/observable'\nimport * as logging from 'lib0/logging'\nimport * as promise from 'lib0/promise'\nimport * as bc from 'lib0/broadcastchannel'\nimport * as buffer from 'lib0/buffer'\nimport * as math from 'lib0/math'\nimport { createMutex } from 'lib0/mutex'\n\nimport * as Y from 'yjs' // eslint-disable-line\nimport Peer from 'simple-peer/simplepeer.min.js'\n\nimport * as syncProtocol from 'y-protocols/sync'\nimport * as awarenessProtocol from 'y-protocols/awareness'\n\nimport * as cryptoutils from './crypto.js'\n\nconst log = logging.createModuleLogger('y-webrtc')\n\nconst messageSync = 0\nconst messageQueryAwareness = 3\nconst messageAwareness = 1\nconst messageBcPeerId = 4\n\n/**\n * @type {Map<string, SignalingConn>}\n */\nconst signalingConns = new Map()\n\n/**\n * @type {Map<string,Room>}\n */\nconst rooms = new Map()\n\n/**\n * @param {Room} room\n */\nconst checkIsSynced = room => {\n  let synced = true\n  room.webrtcConns.forEach(peer => {\n    if (!peer.synced) {\n      synced = false\n    }\n  })\n  if ((!synced && room.synced) || (synced && !room.synced)) {\n    room.synced = synced\n    room.provider.emit('synced', [{ synced }])\n    log('synced ', logging.BOLD, room.name, logging.UNBOLD, ' with all peers')\n  }\n}\n\n/**\n * @param {Room} room\n * @param {Uint8Array} buf\n * @param {function} syncedCallback\n * @return {encoding.Encoder?}\n */\nconst readMessage = (room, buf, syncedCallback) => {\n  const decoder = decoding.createDecoder(buf)\n  const encoder = encoding.createEncoder()\n  const messageType = decoding.readVarUint(decoder)\n  if (room === undefined) {\n    return null\n  }\n  const awareness = room.awareness\n  const doc = room.doc\n  let sendReply = false\n  switch (messageType) {\n    case messageSync: {\n      encoding.writeVarUint(encoder, messageSync)\n      const syncMessageType = syncProtocol.readSyncMessage(decoder, encoder, doc, room)\n      if (syncMessageType === syncProtocol.messageYjsSyncStep2 && !room.synced) {\n        syncedCallback()\n      }\n      if (syncMessageType === syncProtocol.messageYjsSyncStep1) {\n        sendReply = true\n      }\n      break\n    }\n    case messageQueryAwareness:\n      encoding.writeVarUint(encoder, messageAwareness)\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, Array.from(awareness.getStates().keys())))\n      sendReply = true\n      break\n    case messageAwareness:\n      awarenessProtocol.applyAwarenessUpdate(awareness, decoding.readVarUint8Array(decoder), room)\n      break\n    case messageBcPeerId: {\n      const add = decoding.readUint8(decoder) === 1\n      const peerName = decoding.readVarString(decoder)\n      if (peerName !== room.peerId && ((room.bcConns.has(peerName) && !add) || (!room.bcConns.has(peerName) && add))) {\n        const removed = []\n        const added = []\n        if (add) {\n          room.bcConns.add(peerName)\n          added.push(peerName)\n        } else {\n          room.bcConns.delete(peerName)\n          removed.push(peerName)\n        }\n        room.provider.emit('peers', [{\n          added,\n          removed,\n          webrtcPeers: Array.from(room.webrtcConns.keys()),\n          bcPeers: Array.from(room.bcConns)\n        }])\n        broadcastBcPeerId(room)\n      }\n      break\n    }\n    default:\n      console.error('Unable to compute message')\n      return encoder\n  }\n  if (!sendReply) {\n    // nothing has been written, no answer created\n    return null\n  }\n  return encoder\n}\n\n/**\n * @param {WebrtcConn} peerConn\n * @param {Uint8Array} buf\n * @return {encoding.Encoder?}\n */\nconst readPeerMessage = (peerConn, buf) => {\n  const room = peerConn.room\n  log('received message from ', logging.BOLD, peerConn.remotePeerId, logging.GREY, ' (', room.name, ')', logging.UNBOLD, logging.UNCOLOR)\n  return readMessage(room, buf, () => {\n    peerConn.synced = true\n    log('synced ', logging.BOLD, room.name, logging.UNBOLD, ' with ', logging.BOLD, peerConn.remotePeerId)\n    checkIsSynced(room)\n  })\n}\n\n/**\n * @param {WebrtcConn} webrtcConn\n * @param {encoding.Encoder} encoder\n */\nconst sendWebrtcConn = (webrtcConn, encoder) => {\n  log('send message to ', logging.BOLD, webrtcConn.remotePeerId, logging.UNBOLD, logging.GREY, ' (', webrtcConn.room.name, ')', logging.UNCOLOR)\n  try {\n    webrtcConn.peer.send(encoding.toUint8Array(encoder))\n  } catch (e) {}\n}\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastWebrtcConn = (room, m) => {\n  log('broadcast message in ', logging.BOLD, room.name, logging.UNBOLD)\n  room.webrtcConns.forEach(conn => {\n    try {\n      conn.peer.send(m)\n    } catch (e) {}\n  })\n}\n\nexport class WebrtcConn {\n  /**\n   * @param {SignalingConn} signalingConn\n   * @param {boolean} initiator\n   * @param {string} remotePeerId\n   * @param {Room} room\n   */\n  constructor (signalingConn, initiator, remotePeerId, room) {\n    log('establishing connection to ', logging.BOLD, remotePeerId)\n    this.room = room\n    this.remotePeerId = remotePeerId\n    this.closed = false\n    this.connected = false\n    this.synced = false\n    /**\n     * @type {any}\n     */\n    this.peer = new Peer({ initiator, ...room.provider.peerOpts })\n    this.peer.on('signal', signal => {\n      publishSignalingMessage(signalingConn, room, { to: remotePeerId, from: room.peerId, type: 'signal', signal })\n    })\n    this.peer.on('connect', () => {\n      log('connected to ', logging.BOLD, remotePeerId)\n      this.connected = true\n      // send sync step 1\n      const provider = room.provider\n      const doc = provider.doc\n      const awareness = room.awareness\n      const encoder = encoding.createEncoder()\n      encoding.writeVarUint(encoder, messageSync)\n      syncProtocol.writeSyncStep1(encoder, doc)\n      sendWebrtcConn(this, encoder)\n      const awarenessStates = awareness.getStates()\n      if (awarenessStates.size > 0) {\n        const encoder = encoding.createEncoder()\n        encoding.writeVarUint(encoder, messageAwareness)\n        encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, Array.from(awarenessStates.keys())))\n        sendWebrtcConn(this, encoder)\n      }\n    })\n    this.peer.on('close', () => {\n      this.connected = false\n      this.closed = true\n      if (room.webrtcConns.has(this.remotePeerId)) {\n        room.webrtcConns.delete(this.remotePeerId)\n        room.provider.emit('peers', [{\n          removed: [this.remotePeerId],\n          added: [],\n          webrtcPeers: Array.from(room.webrtcConns.keys()),\n          bcPeers: Array.from(room.bcConns)\n        }])\n      }\n      checkIsSynced(room)\n      this.peer.destroy()\n      log('closed connection to ', logging.BOLD, remotePeerId)\n      announceSignalingInfo(room)\n    })\n    this.peer.on('error', err => {\n      log('Error in connection to ', logging.BOLD, remotePeerId, ': ', err)\n      announceSignalingInfo(room)\n    })\n    this.peer.on('data', data => {\n      const answer = readPeerMessage(this, data)\n      if (answer !== null) {\n        sendWebrtcConn(this, answer)\n      }\n    })\n  }\n\n  destroy () {\n    this.peer.destroy()\n  }\n}\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastBcMessage = (room, m) => cryptoutils.encrypt(m, room.key).then(data =>\n  room.mux(() =>\n    bc.publish(room.name, data)\n  )\n)\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastRoomMessage = (room, m) => {\n  if (room.bcconnected) {\n    broadcastBcMessage(room, m)\n  }\n  broadcastWebrtcConn(room, m)\n}\n\n/**\n * @param {Room} room\n */\nconst announceSignalingInfo = room => {\n  signalingConns.forEach(conn => {\n    // only subcribe if connection is established, otherwise the conn automatically subscribes to all rooms\n    if (conn.connected) {\n      conn.send({ type: 'subscribe', topics: [room.name] })\n      if (room.webrtcConns.size < room.provider.maxConns) {\n        publishSignalingMessage(conn, room, { type: 'announce', from: room.peerId })\n      }\n    }\n  })\n}\n\n/**\n * @param {Room} room\n */\nconst broadcastBcPeerId = room => {\n  if (room.provider.filterBcConns) {\n    // broadcast peerId via broadcastchannel\n    const encoderPeerIdBc = encoding.createEncoder()\n    encoding.writeVarUint(encoderPeerIdBc, messageBcPeerId)\n    encoding.writeUint8(encoderPeerIdBc, 1)\n    encoding.writeVarString(encoderPeerIdBc, room.peerId)\n    broadcastBcMessage(room, encoding.toUint8Array(encoderPeerIdBc))\n  }\n}\n\nexport class Room {\n  /**\n   * @param {Y.Doc} doc\n   * @param {WebrtcProvider} provider\n   * @param {string} name\n   * @param {CryptoKey|null} key\n   */\n  constructor (doc, provider, name, key) {\n    /**\n     * Do not assume that peerId is unique. This is only meant for sending signaling messages.\n     *\n     * @type {string}\n     */\n    this.peerId = random.uuidv4()\n    this.doc = doc\n    /**\n     * @type {awarenessProtocol.Awareness}\n     */\n    this.awareness = provider.awareness\n    this.provider = provider\n    this.synced = false\n    this.name = name\n    // @todo make key secret by scoping\n    this.key = key\n    /**\n     * @type {Map<string, WebrtcConn>}\n     */\n    this.webrtcConns = new Map()\n    /**\n     * @type {Set<string>}\n     */\n    this.bcConns = new Set()\n    this.mux = createMutex()\n    this.bcconnected = false\n    /**\n     * @param {ArrayBuffer} data\n     */\n    this._bcSubscriber = data =>\n      cryptoutils.decrypt(new Uint8Array(data), key).then(m =>\n        this.mux(() => {\n          const reply = readMessage(this, m, () => {})\n          if (reply) {\n            broadcastBcMessage(this, encoding.toUint8Array(reply))\n          }\n        })\n      )\n    /**\n     * Listens to Yjs updates and sends them to remote peers\n     *\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n    this._docUpdateHandler = (update, origin) => {\n      const encoder = encoding.createEncoder()\n      encoding.writeVarUint(encoder, messageSync)\n      syncProtocol.writeUpdate(encoder, update)\n      broadcastRoomMessage(this, encoding.toUint8Array(encoder))\n    }\n    /**\n     * Listens to Awareness updates and sends them to remote peers\n     *\n     * @param {any} changed\n     * @param {any} origin\n     */\n    this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {\n      const changedClients = added.concat(updated).concat(removed)\n      const encoderAwareness = encoding.createEncoder()\n      encoding.writeVarUint(encoderAwareness, messageAwareness)\n      encoding.writeVarUint8Array(encoderAwareness, awarenessProtocol.encodeAwarenessUpdate(this.awareness, changedClients))\n      broadcastRoomMessage(this, encoding.toUint8Array(encoderAwareness))\n    }\n\n    this._beforeUnloadHandler = () => {\n      awarenessProtocol.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload')\n      rooms.forEach(room => {\n        room.disconnect()\n      })\n    }\n\n    if (typeof window !== 'undefined') {\n      window.addEventListener('beforeunload', this._beforeUnloadHandler)\n    } else if (typeof process !== 'undefined') {\n      process.on('exit', this._beforeUnloadHandler)\n    }\n  }\n\n  connect () {\n    this.doc.on('update', this._docUpdateHandler)\n    this.awareness.on('update', this._awarenessUpdateHandler)\n    // signal through all available signaling connections\n    announceSignalingInfo(this)\n    const roomName = this.name\n    bc.subscribe(roomName, this._bcSubscriber)\n    this.bcconnected = true\n    // broadcast peerId via broadcastchannel\n    broadcastBcPeerId(this)\n    // write sync step 1\n    const encoderSync = encoding.createEncoder()\n    encoding.writeVarUint(encoderSync, messageSync)\n    syncProtocol.writeSyncStep1(encoderSync, this.doc)\n    broadcastBcMessage(this, encoding.toUint8Array(encoderSync))\n    // broadcast local state\n    const encoderState = encoding.createEncoder()\n    encoding.writeVarUint(encoderState, messageSync)\n    syncProtocol.writeSyncStep2(encoderState, this.doc)\n    broadcastBcMessage(this, encoding.toUint8Array(encoderState))\n    // write queryAwareness\n    const encoderAwarenessQuery = encoding.createEncoder()\n    encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness)\n    broadcastBcMessage(this, encoding.toUint8Array(encoderAwarenessQuery))\n    // broadcast local awareness state\n    const encoderAwarenessState = encoding.createEncoder()\n    encoding.writeVarUint(encoderAwarenessState, messageAwareness)\n    encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]))\n    broadcastBcMessage(this, encoding.toUint8Array(encoderAwarenessState))\n  }\n\n  disconnect () {\n    // signal through all available signaling connections\n    signalingConns.forEach(conn => {\n      if (conn.connected) {\n        conn.send({ type: 'unsubscribe', topics: [this.name] })\n      }\n    })\n    awarenessProtocol.removeAwarenessStates(this.awareness, [this.doc.clientID], 'disconnect')\n    // broadcast peerId removal via broadcastchannel\n    const encoderPeerIdBc = encoding.createEncoder()\n    encoding.writeVarUint(encoderPeerIdBc, messageBcPeerId)\n    encoding.writeUint8(encoderPeerIdBc, 0) // remove peerId from other bc peers\n    encoding.writeVarString(encoderPeerIdBc, this.peerId)\n    broadcastBcMessage(this, encoding.toUint8Array(encoderPeerIdBc))\n\n    bc.unsubscribe(this.name, this._bcSubscriber)\n    this.bcconnected = false\n    this.doc.off('update', this._docUpdateHandler)\n    this.awareness.off('update', this._awarenessUpdateHandler)\n    this.webrtcConns.forEach(conn => conn.destroy())\n  }\n\n  destroy () {\n    this.disconnect()\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('beforeunload', this._beforeUnloadHandler)\n    } else if (typeof process !== 'undefined') {\n      process.off('exit', this._beforeUnloadHandler)\n    }\n  }\n}\n\n/**\n * @param {Y.Doc} doc\n * @param {WebrtcProvider} provider\n * @param {string} name\n * @param {CryptoKey|null} key\n * @return {Room}\n */\nconst openRoom = (doc, provider, name, key) => {\n  // there must only be one room\n  if (rooms.has(name)) {\n    throw error.create(`A Yjs Doc connected to room \"${name}\" already exists!`)\n  }\n  const room = new Room(doc, provider, name, key)\n  rooms.set(name, /** @type {Room} */ (room))\n  return room\n}\n\n/**\n * @param {SignalingConn} conn\n * @param {Room} room\n * @param {any} data\n */\nconst publishSignalingMessage = (conn, room, data) => {\n  if (room.key) {\n    cryptoutils.encryptJson(data, room.key).then(data => {\n      conn.send({ type: 'publish', topic: room.name, data: buffer.toBase64(data) })\n    })\n  } else {\n    conn.send({ type: 'publish', topic: room.name, data })\n  }\n}\n\nexport class SignalingConn extends ws.WebsocketClient {\n  constructor (url) {\n    super(url)\n    /**\n     * @type {Set<WebrtcProvider>}\n     */\n    this.providers = new Set()\n    this.on('connect', () => {\n      log(`connected (${url})`)\n      const topics = Array.from(rooms.keys())\n      this.send({ type: 'subscribe', topics })\n      rooms.forEach(room =>\n        publishSignalingMessage(this, room, { type: 'announce', from: room.peerId })\n      )\n    })\n    this.on('message', m => {\n      switch (m.type) {\n        case 'publish': {\n          const roomName = m.topic\n          const room = rooms.get(roomName)\n          if (room == null || typeof roomName !== 'string') {\n            return\n          }\n          const execMessage = data => {\n            const webrtcConns = room.webrtcConns\n            const peerId = room.peerId\n            if (data == null || data.from === peerId || (data.to !== undefined && data.to !== peerId) || room.bcConns.has(data.from)) {\n              // ignore messages that are not addressed to this conn, or from clients that are connected via broadcastchannel\n              return\n            }\n            const emitPeerChange = webrtcConns.has(data.from)\n              ? () => {}\n              : () =>\n                room.provider.emit('peers', [{\n                  removed: [],\n                  added: [data.from],\n                  webrtcPeers: Array.from(room.webrtcConns.keys()),\n                  bcPeers: Array.from(room.bcConns)\n                }])\n            switch (data.type) {\n              case 'announce':\n                if (webrtcConns.size < room.provider.maxConns) {\n                  map.setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, true, data.from, room))\n                  emitPeerChange()\n                }\n                break\n              case 'signal':\n                if (data.to === peerId) {\n                  map.setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, false, data.from, room)).peer.signal(data.signal)\n                  emitPeerChange()\n                }\n                break\n            }\n          }\n          if (room.key) {\n            if (typeof m.data === 'string') {\n              cryptoutils.decryptJson(buffer.fromBase64(m.data), room.key).then(execMessage)\n            }\n          } else {\n            execMessage(m.data)\n          }\n        }\n      }\n    })\n    this.on('disconnect', () => log(`disconnect (${url})`))\n  }\n}\n\n/**\n * @extends Observable<string>\n */\nexport class WebrtcProvider extends Observable {\n  /**\n   * @param {string} roomName\n   * @param {Y.Doc} doc\n   * @param {Object} [opts]\n   * @param {Array<string>?} [opts.signaling]\n   * @param {string?} [opts.password]\n   * @param {awarenessProtocol.Awareness?} [opts.awareness]\n   * @param {number?} [opts.maxConns]\n   * @param {boolean?} [opts.filterBcConns]\n   * @param {any?} [opts.peerOpts]\n   */\n  constructor (\n    roomName,\n    doc,\n    {\n      signaling = ['wss://signaling.yjs.dev', 'wss://y-webrtc-signaling-eu.herokuapp.com', 'wss://y-webrtc-signaling-us.herokuapp.com'],\n      password = null,\n      awareness = new awarenessProtocol.Awareness(doc),\n      maxConns = 20 + math.floor(random.rand() * 15), // the random factor reduces the chance that n clients form a cluster\n      filterBcConns = true,\n      peerOpts = {} // simple-peer options. See https://github.com/feross/simple-peer#peer--new-peeropts\n    } = {}\n  ) {\n    super()\n    this.roomName = roomName\n    this.doc = doc\n    this.filterBcConns = filterBcConns\n    /**\n     * @type {awarenessProtocol.Awareness}\n     */\n    this.awareness = awareness\n    this.shouldConnect = false\n    this.signalingUrls = signaling\n    this.signalingConns = []\n    this.maxConns = maxConns\n    this.peerOpts = peerOpts\n    /**\n     * @type {PromiseLike<CryptoKey | null>}\n     */\n    this.key = password ? cryptoutils.deriveKey(password, roomName) : /** @type {PromiseLike<null>} */ (promise.resolve(null))\n    /**\n     * @type {Room|null}\n     */\n    this.room = null\n    this.key.then(key => {\n      this.room = openRoom(doc, this, roomName, key)\n      if (this.shouldConnect) {\n        this.room.connect()\n      } else {\n        this.room.disconnect()\n      }\n    })\n    this.connect()\n    this.destroy = this.destroy.bind(this)\n    doc.on('destroy', this.destroy)\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get connected () {\n    return this.room !== null && this.shouldConnect\n  }\n\n  connect () {\n    this.shouldConnect = true\n    this.signalingUrls.forEach(url => {\n      const signalingConn = map.setIfUndefined(signalingConns, url, () => new SignalingConn(url))\n      this.signalingConns.push(signalingConn)\n      signalingConn.providers.add(this)\n    })\n    if (this.room) {\n      this.room.connect()\n    }\n  }\n\n  disconnect () {\n    this.shouldConnect = false\n    this.signalingConns.forEach(conn => {\n      conn.providers.delete(this)\n      if (conn.providers.size === 0) {\n        conn.destroy()\n        signalingConns.delete(conn.url)\n      }\n    })\n    if (this.room) {\n      this.room.disconnect()\n    }\n  }\n\n  destroy () {\n    this.doc.off('destroy', this.destroy)\n    // need to wait for key before deleting room\n    this.key.then(() => {\n      /** @type {Room} */ (this.room).destroy()\n      rooms.delete(this.roomName)\n    })\n    super.destroy()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}