{"ast":null,"code":"/* eslint-env browser */\n\n/**\n * Tiny websocket connection handler.\n *\n * Implements exponential backoff reconnects, ping/pong, and a nice event system using [lib0/observable].\n *\n * @module websocket\n */\n\nimport { Observable } from './observable.js';\nimport * as time from './time.js';\nimport * as math from './math.js';\nconst reconnectTimeoutBase = 1200;\nconst maxReconnectTimeout = 2500;\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000;\n\n/**\n * @param {WebsocketClient} wsclient\n */\nconst setupWS = wsclient => {\n  if (wsclient.shouldConnect && wsclient.ws === null) {\n    const websocket = new WebSocket(wsclient.url);\n    const binaryType = wsclient.binaryType;\n    /**\n     * @type {any}\n     */\n    let pingTimeout = null;\n    if (binaryType) {\n      websocket.binaryType = binaryType;\n    }\n    wsclient.ws = websocket;\n    wsclient.connecting = true;\n    wsclient.connected = false;\n    websocket.onmessage = event => {\n      wsclient.lastMessageReceived = time.getUnixTime();\n      const data = event.data;\n      const message = typeof data === 'string' ? JSON.parse(data) : data;\n      if (message && message.type === 'pong') {\n        clearTimeout(pingTimeout);\n        pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);\n      }\n      wsclient.emit('message', [message, wsclient]);\n    };\n    /**\n     * @param {any} error\n     */\n    const onclose = error => {\n      if (wsclient.ws !== null) {\n        wsclient.ws = null;\n        wsclient.connecting = false;\n        if (wsclient.connected) {\n          wsclient.connected = false;\n          wsclient.emit('disconnect', [{\n            type: 'disconnect',\n            error\n          }, wsclient]);\n        } else {\n          wsclient.unsuccessfulReconnects++;\n        }\n        // Start with no reconnect timeout and increase timeout by\n        // log10(wsUnsuccessfulReconnects).\n        // The idea is to increase reconnect timeout slowly and have no reconnect\n        // timeout at the beginning (log(1) = 0)\n        setTimeout(setupWS, math.min(math.log10(wsclient.unsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), wsclient);\n      }\n      clearTimeout(pingTimeout);\n    };\n    const sendPing = () => {\n      if (wsclient.ws === websocket) {\n        wsclient.send({\n          type: 'ping'\n        });\n      }\n    };\n    websocket.onclose = () => onclose(null);\n    websocket.onerror = error => onclose(error);\n    websocket.onopen = () => {\n      wsclient.lastMessageReceived = time.getUnixTime();\n      wsclient.connecting = false;\n      wsclient.connected = true;\n      wsclient.unsuccessfulReconnects = 0;\n      wsclient.emit('connect', [{\n        type: 'connect'\n      }, wsclient]);\n      // set ping\n      pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);\n    };\n  }\n};\n\n/**\n * @extends Observable<string>\n */\nexport class WebsocketClient extends Observable {\n  /**\n   * @param {string} url\n   * @param {object} [opts]\n   * @param {'arraybuffer' | 'blob' | null} [opts.binaryType] Set `ws.binaryType`\n   */\n  constructor(url) {\n    let {\n      binaryType\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.url = url;\n    /**\n     * @type {WebSocket?}\n     */\n    this.ws = null;\n    this.binaryType = binaryType || null;\n    this.connected = false;\n    this.connecting = false;\n    this.unsuccessfulReconnects = 0;\n    this.lastMessageReceived = 0;\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n    this.shouldConnect = true;\n    this._checkInterval = setInterval(() => {\n      if (this.connected && messageReconnectTimeout < time.getUnixTime() - this.lastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        /** @type {WebSocket} */\n        this.ws.close();\n      }\n    }, messageReconnectTimeout / 2);\n    setupWS(this);\n  }\n\n  /**\n   * @param {any} message\n   */\n  send(message) {\n    if (this.ws) {\n      this.ws.send(JSON.stringify(message));\n    }\n  }\n  destroy() {\n    clearInterval(this._checkInterval);\n    this.disconnect();\n    super.destroy();\n  }\n  disconnect() {\n    this.shouldConnect = false;\n    if (this.ws !== null) {\n      this.ws.close();\n    }\n  }\n  connect() {\n    this.shouldConnect = true;\n    if (!this.connected && this.ws === null) {\n      setupWS(this);\n    }\n  }\n}","map":{"version":3,"names":["Observable","time","math","reconnectTimeoutBase","maxReconnectTimeout","messageReconnectTimeout","setupWS","wsclient","shouldConnect","ws","websocket","WebSocket","url","binaryType","pingTimeout","connecting","connected","onmessage","event","lastMessageReceived","getUnixTime","data","message","JSON","parse","type","clearTimeout","setTimeout","sendPing","emit","onclose","error","unsuccessfulReconnects","min","log10","send","onerror","onopen","WebsocketClient","constructor","_checkInterval","setInterval","close","stringify","destroy","clearInterval","disconnect","connect"],"sources":["/root/ms1/node_modules/lib0/websocket.js"],"sourcesContent":["/* eslint-env browser */\n\n/**\n * Tiny websocket connection handler.\n *\n * Implements exponential backoff reconnects, ping/pong, and a nice event system using [lib0/observable].\n *\n * @module websocket\n */\n\nimport { Observable } from './observable.js'\nimport * as time from './time.js'\nimport * as math from './math.js'\n\nconst reconnectTimeoutBase = 1200\nconst maxReconnectTimeout = 2500\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000\n\n/**\n * @param {WebsocketClient} wsclient\n */\nconst setupWS = (wsclient) => {\n  if (wsclient.shouldConnect && wsclient.ws === null) {\n    const websocket = new WebSocket(wsclient.url)\n    const binaryType = wsclient.binaryType\n    /**\n     * @type {any}\n     */\n    let pingTimeout = null\n    if (binaryType) {\n      websocket.binaryType = binaryType\n    }\n    wsclient.ws = websocket\n    wsclient.connecting = true\n    wsclient.connected = false\n    websocket.onmessage = event => {\n      wsclient.lastMessageReceived = time.getUnixTime()\n      const data = event.data\n      const message = typeof data === 'string' ? JSON.parse(data) : data\n      if (message && message.type === 'pong') {\n        clearTimeout(pingTimeout)\n        pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2)\n      }\n      wsclient.emit('message', [message, wsclient])\n    }\n    /**\n     * @param {any} error\n     */\n    const onclose = error => {\n      if (wsclient.ws !== null) {\n        wsclient.ws = null\n        wsclient.connecting = false\n        if (wsclient.connected) {\n          wsclient.connected = false\n          wsclient.emit('disconnect', [{ type: 'disconnect', error }, wsclient])\n        } else {\n          wsclient.unsuccessfulReconnects++\n        }\n        // Start with no reconnect timeout and increase timeout by\n        // log10(wsUnsuccessfulReconnects).\n        // The idea is to increase reconnect timeout slowly and have no reconnect\n        // timeout at the beginning (log(1) = 0)\n        setTimeout(setupWS, math.min(math.log10(wsclient.unsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), wsclient)\n      }\n      clearTimeout(pingTimeout)\n    }\n    const sendPing = () => {\n      if (wsclient.ws === websocket) {\n        wsclient.send({\n          type: 'ping'\n        })\n      }\n    }\n    websocket.onclose = () => onclose(null)\n    websocket.onerror = error => onclose(error)\n    websocket.onopen = () => {\n      wsclient.lastMessageReceived = time.getUnixTime()\n      wsclient.connecting = false\n      wsclient.connected = true\n      wsclient.unsuccessfulReconnects = 0\n      wsclient.emit('connect', [{ type: 'connect' }, wsclient])\n      // set ping\n      pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2)\n    }\n  }\n}\n\n/**\n * @extends Observable<string>\n */\nexport class WebsocketClient extends Observable {\n  /**\n   * @param {string} url\n   * @param {object} [opts]\n   * @param {'arraybuffer' | 'blob' | null} [opts.binaryType] Set `ws.binaryType`\n   */\n  constructor (url, { binaryType } = {}) {\n    super()\n    this.url = url\n    /**\n     * @type {WebSocket?}\n     */\n    this.ws = null\n    this.binaryType = binaryType || null\n    this.connected = false\n    this.connecting = false\n    this.unsuccessfulReconnects = 0\n    this.lastMessageReceived = 0\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n    this.shouldConnect = true\n    this._checkInterval = setInterval(() => {\n      if (this.connected && messageReconnectTimeout < time.getUnixTime() - this.lastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        /** @type {WebSocket} */ (this.ws).close()\n      }\n    }, messageReconnectTimeout / 2)\n    setupWS(this)\n  }\n\n  /**\n   * @param {any} message\n   */\n  send (message) {\n    if (this.ws) {\n      this.ws.send(JSON.stringify(message))\n    }\n  }\n\n  destroy () {\n    clearInterval(this._checkInterval)\n    this.disconnect()\n    super.destroy()\n  }\n\n  disconnect () {\n    this.shouldConnect = false\n    if (this.ws !== null) {\n      this.ws.close()\n    }\n  }\n\n  connect () {\n    this.shouldConnect = true\n    if (!this.connected && this.ws === null) {\n      setupWS(this)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}